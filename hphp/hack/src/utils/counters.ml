(*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the "hack" directory of this source tree.
 *
 *)

open Hh_prelude

exception WrongEnum

module Category = struct
  type t =
    | Disk_cat
    | Direct_decl_parse
    | Decl_provider_get
    | Ast_provider_get
    | Typing_toplevel
  [@@deriving ord, enum, show { with_path = false }]

  let count = (* max here is generated by ppx enum *) max + 1

  let _ = min (* otherwise warning that it's unused *)
end

module CategorySet = Stdlib.Set.Make (Category)

type time_in_sec = float

type counter = {
  count: int;  (** how many times did 'count' get called? *)
  time: time_in_sec;  (** cumulative duration of all calls to 'count' *)
}

let empty = { count = 0; time = 0. }

(** here we store each individual counter. *)
type t =
  (* Making this a map causes 1% typing time regression. *)
  counter Array.t

let counters : t ref = ref (Array.create ~len:Category.count empty)

let restore_state (new_state : t) : unit = counters := new_state

let reset () : t =
  let old_counters = !counters in
  counters := Array.create ~len:Category.count empty;
  old_counters

let get_counter (category : Category.t) : counter =
  !counters.(Category.to_enum category)

let set_counter (category : Category.t) (counts : counter) : unit =
  !counters.(Category.to_enum category) <- counts

let count (category : Category.t) (f : unit -> 'a) : 'a =
  let tally = get_counter category in
  let start_time = Unix.gettimeofday () in
  Utils.try_finally ~f ~finally:(fun () ->
      set_counter
        category
        {
          count = tally.count + 1;
          time = tally.time +. Unix.gettimeofday () -. start_time;
        })

let read_time (category : Category.t) : time_in_sec =
  (get_counter category).time

let get_counters () : Telemetry.t =
  let telemetry_of_counter counter =
    Telemetry.create ()
    |> Telemetry.int_ ~key:"count" ~value:counter.count
    |> Telemetry.duration ~start_time:0. ~end_time:counter.time
  in
  let telemetry =
    Array.foldi
      ~f:(fun i telemetry counter ->
        let category =
          match Category.of_enum i with
          | Some cat -> cat
          | None -> raise WrongEnum
        in
        let telemetry =
          Telemetry.object_
            telemetry
            ~key:(Category.show category)
            ~value:(telemetry_of_counter counter)
        in
        telemetry)
      !counters
      ~init:(Telemetry.create ())
  in
  telemetry
